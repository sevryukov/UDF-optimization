/***
Проблема 1 Анализ:
Из описания мы знаем, что dbo.F_WORKS_LIST() - это определяемая пользователем функция (UDF), 
которая может быть предназначена для возврата списка заказов. Хотя у нас нет реального сценария для 
этой функции, мы можем определить возможные недостатки и проблемы производительности, 
основываясь на обычном использовании UDF в SQL Server и соображениях производительности.
Выявленные недостатки и потенциальные проблемы с производительностью:
UDF как источник данных: использование UDF непосредственно в операторах SELECT (особенно если 
они возвращают большое количество строк) может привести к проблемам с производительностью. 
Каждый вызов UDF выполняет свою собственную внутреннюю логику SQL, и эта логика может быть 
повторно выполнена для каждой строки возвращаемого результата.
Отсутствие фильтрации и сортировки: использование SELECT TOP 3000 * может означать отсутствие 
фильтрации по определенным условиям и сортировки результатов. Это может привести к возврату 
ненужных данных и увеличению времени передачи данных по сети и обработки на стороне клиента.
Внутренняя логика UDF: если UDF содержит сложную внутреннюю логику запросов, такую как 
соединения нескольких таблиц, подзапросы, агрегатные функции и т. д., это может существенно 
повлиять на производительность.
Отсутствие индексов: если таблица Works (или связанные с ней таблицы) не имеет надлежащих индексов 
для поддержки запросов в UDF, это может повлиять на производительность.
Борьба за ресурсы: если UDF вызывается часто в часы пик, он может конкурировать с другими запросами 
за ресурсы процессора, памяти или ввода-вывода, что приведет к снижению производительности.
Размер набора результатов: SELECT * может возвращать большой объем данных, особенно если таблица 
имеет много столбцов. Это может увеличить время передачи данных по сети и время обработки запроса 
клиентом.
***/


--Вторая задача：
ALTER FUNCTION [dbo].[F_WORKS_LIST]()
RETURNS @Results TABLE (
 ID_WORK INT,
 ResponsibleEmployeeFullName VARCHAR(101),
 NotCompletedWorkItemsCount INT,
 CompletedWorkItemsCount INT
)
AS
BEGIN
 -- 1. 获取所有 Works 和对应的 EmployeeID （ Получите все работы и соответствующий
идентификатор сотрудника）
 DECLARE @WorksCursor CURSOR FOR
 SELECT TOP 3000 ID_WORK, EmployeeID -- 限制检索的订单数量为 3000（Ограничьте количество
полученных заказов до 3000）
 FROM Works;
 -- 打开游标并处理每个 Works 条目（Откройте курсор и обработайте каждую запись о работе）
 OPEN @WorksCursor;
 FETCH NEXT FROM @WorksCursor INTO @ID_WORK, @EmployeeID;
 WHILE @@FETCH_STATUS = 0
 BEGIN
 -- 假设我们已经有了一个函数或查询来获取全名（Предположим, у нас уже есть функция или
запрос для получения полного имени）
 DECLARE @FullName VARCHAR(101) = dbo.F_EMPLOYEE_FULLNAME(@EmployeeID);
 -- 假设我们已经有了一个函数来获取工作项计数（Предположим, у нас уже есть функция для
получения количества рабочих элементов）
 DECLARE @NotCompletedCount INT = 
dbo.F_WORKITEMS_COUNT_BY_ID_WORK(@ID_WORK, 0);
 DECLARE @CompletedCount INT = 
dbo.F_WORKITEMS_COUNT_BY_ID_WORK(@ID_WORK, 1);
 -- 将结果插入到表变量中（Вставьте результат в табличную переменную）
 INSERT INTO @Results (ID_WORK, ResponsibleEmployeeFullName, 
NotCompletedWorkItemsCount, CompletedWorkItemsCount)
 VALUES (@ID_WORK, @FullName, @NotCompletedCount, @CompletedCount);
 -- 获取下一个 Works 条目（Получите следующую запись о работе）
 FETCH NEXT FROM @WorksCursor INTO @ID_WORK, @EmployeeID;
 END;
 -- 关闭并释放游标（Закройте и отпустите курсор）
 CLOSE @WorksCursor;
 DEALLOCATE @WorksCursor;
 -- 返回结果集（Возвращаемый результирующий набор）
 RETURN;
END;
-- 在 Works 表中为 ID_WORK 列和 EmployeeID 列添加索引（Добавьте индекс к столбцу ID_WORK 
и столбцу EmployeeID в таблице Works）
CREATE INDEX idx_ID_WORK ON Works (ID_WORK);
CREATE INDEX idx_EmployeeID ON Works (EmployeeID);


/***
Анализ проблемы 3：
Потенциальные недостатки и негативные последствия создания новых таблиц, столбцов, триггеров или 
хранимых процедур:
Повышенная сложность: добавление новых объектов базы данных (например, таблиц, столбцов, 
триггеров и т. д.) повышает сложность системы, что может затруднить обслуживание и устранение 
неполадок.
Избыточность данных: создание новых таблиц для хранения промежуточных результатов или 
агрегированных данных может привести к избыточности данных и риску их несогласованности.
Проблемы с производительностью: хотя новые хранимые процедуры или триггеры могут быть 
предназначены для повышения производительности, они могут также создавать новые узкие места, 
особенно если они неправильно спроектированы и оптимизированы.
Влияние на существующие приложения: если новые объекты базы данных требуют изменений в 
существующей логике приложения (например, вместо использования UDF необходимо вызывать новые 
хранимые процедуры), это может потребовать значительных усилий по разработке и может привести к 
появлению новых ошибок.
Дополнительные расходы на обслуживание: новый объект базы данных требует дополнительного 
обслуживания, включая резервное копирование, восстановление, контроль версий и т. д.
Проблемы с зависимостями: если между новыми объектами базы данных существуют сложные 
зависимости, то изменения в одном объекте могут повлиять на поведение других объектов.
Использование ресурсов: новые объекты базы данных могут увеличить потребность в ресурсах сервера 
базы данных, таких как процессор, память и пространство для хранения данных.
Требования к тестированию: добавление новых объектов базы данных требует дополнительного 
тестирования, чтобы убедиться, что они работают так, как ожидается, и не оказывают негативного 
влияния на существующую функциональность
***/