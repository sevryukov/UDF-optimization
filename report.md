# Задание 1
1. Функция F_EMPLOYEE_FULLNAME может ухудшать производительность из-за вызова внутри функции F_EMPLOYEE_GET.
2. В функции F_WORKITEMS_COUNT_BY_ID_WORK есть 2 пабгубных для производительности момента: 
    *  count(*) считает все строки, а не только те, где есть where. Эффективнее будет использовать count(field)
    *  В функции используется подзапрос для фильтрации id_analiz. Лучше этого избегать.
3. В F_WORKS_LIST Функции dbo.F_WORKITEMS_COUNT_BY_ID_WORK и dbo.F_EMPLOYEE_FULLNAME вызываются для каждой строки результата SELECT-запроса. 

# Задание 2
Проводились изменения функции F_WORKS_LIST. В данной оптимизированной версии функции я заменил вызовы функций F_WORKITEMS_COUNT_BY_ID_WORK на подзапросы для подсчета количества элементов работ. Также убрал использование функций в предикатах и переписал условие для столбца Is_Print без использования функции в нем.

# Задание 3
1. Создание предварительно рассчитанных таблиц: Можно создать таблицу EmployeeFullName для хранения предварительно рассчитанных имен сотрудников. Это позволит избежать повторных вычислений имени при каждом запросе. Однако, недостатком такого подхода будет необходимость пересчета информации в таблице EmployeeFullName при изменении имени или логина сотрудника.

2. Использование триггеров для автоматического обновления данных: Создание триггера для автоматического обновления суммы продаж или других данных при вставке, обновлении или удалении записей может значительно упростить процесс поддержания актуальности информации. Однако, необходимо быть внимательным к производительности, так как триггеры могут добавить нагрузку на базу данных.

3. Использование хранимых процедур для выполнения сложных операций: Создание хранимых процедур для выполнения сложных операций, например, расчета скидок или обновления сводной информации, может повысить производительность и упростить разработку приложения. Однако, изменение логики в хранимых процедурах может потребовать дополнительного внимания к обновлению соответствующих данных.